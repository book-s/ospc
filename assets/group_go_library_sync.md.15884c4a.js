import{_ as o,c as n,o as e,a as t}from"./app.a7d8838a.js";const l=JSON.parse('{"title":"sync","description":"","frontmatter":{},"headers":[],"relativePath":"group/go/library/sync.md"}'),c={name:"group/go/library/sync.md"},r=t('<h1 id="sync" tabindex="-1">sync <a class="header-anchor" href="#sync" aria-hidden="true">#</a></h1><p><code>sync</code> 是 Go 语言标准库中提供的一个并发原语包，它包含了一些常用的同步原语，如互斥锁、读写锁、条件变量等，以及一些高级的同步机制，如 WaitGroup 和 Once 等。</p><p>sync 的设计原理主要包括以下几个方面：</p><ul><li><p><strong>1、原子性操作</strong><br><code>sync</code> 中的许多同步原语都是基于原子性操作实现的，例如 <code>sync/atomic</code> 包中的函数。原子性操作是指操作的执行是不可分割的，不能被其他操作中断。在并发环境中，原子性操作可以保证多个 goroutine 同时操作同一个变量时不会出现竞争条件。</p></li><li><p><strong>2、互斥锁</strong><br><code>sync.Mutex</code> 是 sync 包中最基本的同步原语之一。互斥锁用于在多个 goroutine 之间同步对共享资源的访问，保证同时只有一个 goroutine 可以访问共享资源。在 <code>sync.Mutex</code> 中，通过 CAS 操作实现了对共享资源的访问控制，同时在竞争条件发生时，还可以保证 goroutine 的公平性。</p></li><li><p><strong>3、读写锁</strong><br> sync.RWMutex 是 sync 包中的另一个同步原语，它用于在多个 goroutine 之间同步对共享资源的读写访问。sync.RWMutex 可以支持多个 goroutine 并发读取共享资源，但只能有一个 goroutine 写入共享资源。通过 sync.RWMutex，可以有效地减少读写竞争条件的发生，提高并发访问的效率。</p></li><li><p><strong>4、条件变量</strong><br> sync.Cond 是 sync 包中的一个条件变量类型，用于在多个 goroutine 之间同步和传递信息。当一个 goroutine 需要等待某个条件满足时，它可以通过等待 sync.Cond 上的信号来挂起自己，而另外的 goroutine 在条件满足时可以通过发送信号来唤醒被挂起的 goroutine。通过 sync.Cond，可以实现更加复杂的同步机制，如生产者-消费者模型、事件通知等。</p></li><li><p><strong>5、其他同步原语</strong><br> 除了互斥锁、读写锁和条件变量外，sync 包还提供了其他一些同步原语，如 sync.WaitGroup 和 sync.Once。sync.WaitGroup 可以用于等待一组 goroutine 执行完毕后再执行后续操作，而 sync.Once 可以用于确保某个操作只执行一次，即使多个 goroutine 同时尝试执行。</p></li></ul>',4),s=[r];function i(a,u,d,p,y,g){return e(),n("div",null,s)}const h=o(c,[["render",i]]);export{l as __pageData,h as default};
